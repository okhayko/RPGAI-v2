/**
 * Quest Reward Processor - Automatically grants quest rewards when quests are completed
 * This ensures rewards are always properly added to the player's inventory and stats
 */

import type { Entity, Quest } from '../types';

export interface QuestReward {
    type: 'item' | 'currency' | 'experience' | 'skill' | 'skill_exp' | 'status' | 'unknown';
    name: string;
    quantity: number;
    description?: string;
    originalText: string;
}

export interface RewardProcessingResult {
    rewards: QuestReward[];
    commandTags: string[];
    errors: string[];
    questTitle: string;
}

/**
 * Parse a quest reward string into structured rewards
 * Examples:
 * - "Linh Th·∫°ch H·∫° Ph·∫©m (3 vi√™n)" -> { type: 'item', name: 'Linh Th·∫°ch H·∫° Ph·∫©m', quantity: 3 }
 * - "ƒêi·ªÉm c·ªëng hi·∫øn t√¥ng m√¥n" -> { type: 'currency', name: 'ƒêi·ªÉm c·ªëng hi·∫øn t√¥ng m√¥n', quantity: 1 }
 * - "Kinh nghi·ªám tu luy·ªán" -> { type: 'experience', name: 'Kinh nghi·ªám tu luy·ªán', quantity: 1 }
 */
export const parseQuestReward = (rewardText: string): QuestReward[] => {
    if (!rewardText || rewardText.trim() === '') {
        return [];
    }

    const rewards: QuestReward[] = [];
    console.log(`üéÅ Parsing reward text: "${rewardText}"`);
    
    // Split by common separators (semicolon, comma, "and", etc.)
    const rewardParts = rewardText.split(/[;,]|,\s*v√†\s*|\s*v√†\s*|\s*,\s*/)
        .map(part => part.trim())
        .filter(part => part.length > 0);

    for (const part of rewardParts) {
        console.log(`üîç Processing reward part: "${part}"`);
        
        // Extract quantity from parentheses like "(3 vi√™n)", "(10)", etc.
        const quantityMatch = part.match(/\((\d+)(?:\s*vi√™n|\s*l∆∞·ª£ng|\s*ƒëi·ªÉm)?\)/i);
        const quantity = quantityMatch ? parseInt(quantityMatch[1], 10) : 1;
        
        // Remove the quantity part to get clean name
        const cleanName = part.replace(/\s*\(\d+(?:\s*vi√™n|\s*l∆∞·ª£ng|\s*ƒëi·ªÉm)?\)/i, '').trim();
        
        // Determine reward type based on keywords
        let rewardType: QuestReward['type'] = 'unknown';
        
        if (cleanName.toLowerCase().includes('linh th·∫°ch') || 
            cleanName.toLowerCase().includes('ƒë·ªìng') ||
            cleanName.toLowerCase().includes('b·∫°c') ||
            cleanName.toLowerCase().includes('v√†ng') ||
            cleanName.toLowerCase().includes('ƒëi·ªÉm')) {
            rewardType = 'currency';
        } else if (cleanName.toLowerCase().includes('kinh nghi·ªám chi·∫øn ƒë·∫•u') ||
                   cleanName.toLowerCase().includes('skill exp') ||
                   cleanName.toLowerCase().includes('combat exp')) {
            rewardType = 'skill_exp';  // Combat experience goes to skills
        } else if (cleanName.toLowerCase().includes('kinh nghi·ªám') ||
                   cleanName.toLowerCase().includes('exp')) {
            rewardType = 'experience';  // Regular experience goes to character
        } else if (cleanName.toLowerCase().includes('k·ªπ nƒÉng') ||
                   cleanName.toLowerCase().includes('skill') ||
                   cleanName.toLowerCase().includes('c√¥ng ph√°p') ||
                   cleanName.toLowerCase().includes('ki·∫øm ph√°p') ||
                   cleanName.toLowerCase().includes('ph√°p thu·∫≠t') ||
                   cleanName.toLowerCase().includes('martial') ||
                   cleanName.toLowerCase().includes('technique')) {
            rewardType = 'skill';
        } else if (cleanName.toLowerCase().includes('buff') ||
                   cleanName.toLowerCase().includes('tr·∫°ng th√°i')) {
            rewardType = 'status';
        } else {
            // Default to item for everything else
            rewardType = 'item';
        }

        const reward: QuestReward = {
            type: rewardType,
            name: cleanName,
            quantity: quantity,
            originalText: part
        };

        rewards.push(reward);
        console.log(`‚úÖ Parsed reward: ${reward.type} "${reward.name}" x${reward.quantity}`);
    }

    return rewards;
};

/**
 * Generate command tags for applying quest rewards
 */
export const generateRewardCommandTags = (
    rewards: QuestReward[], 
    questTitle: string,
    knownEntities: { [key: string]: Entity }
): { commandTags: string[], errors: string[] } => {
    const commandTags: string[] = [];
    const errors: string[] = [];

    console.log(`üèóÔ∏è Generating command tags for ${rewards.length} rewards from quest "${questTitle}"`);

    for (const reward of rewards) {
        try {
            if (reward.quantity <= 0) {
                errors.push(`Invalid quantity for reward "${reward.name}": ${reward.quantity}`);
                continue;
            }

            switch (reward.type) {
                case 'item':
                case 'currency':
                    // Check for hidden items (V·∫≠t ph·∫©m ·∫©n) that need special AI generation
                    if (reward.name.toLowerCase().includes('v·∫≠t ph·∫©m ·∫©n') || 
                        reward.name.toLowerCase().includes('hidden item')) {
                        // Generate special AI creation tag for hidden items
                        const hiddenItemTag = `[SPECIAL_ITEM_GENERATE: questTitle="${questTitle}", quantities=${reward.quantity}, category="mysterious_reward", rarity="rare", generateUnique=true, owner="pc"]`;
                        commandTags.push(hiddenItemTag);
                        console.log(`üéÅ Generated hidden item generation tag: ${hiddenItemTag}`);
                    } else {
                        // Check if item already exists to get description
                        const existingItem = knownEntities[reward.name];
                        const description = existingItem?.description || 
                            generateDefaultDescription(reward.name, reward.type);
                        
                        const itemTag = `[ITEM_AQUIRED: name="${reward.name}", description="${description}", quantities=${reward.quantity}, usable=true, owner="pc"]`;
                        commandTags.push(itemTag);
                        console.log(`üí∞ Generated item tag: ${itemTag}`);
                    }
                    break;

                case 'experience':
                    // Update character experience stats using ENTITY_UPDATE
                    const pcEntity = Object.values(knownEntities).find(entity => entity.type === 'pc');
                    if (pcEntity) {
                        const expTag = `[ENTITY_UPDATE: name="${pcEntity.name}", type="pc", attribute="currentExp", change="+${reward.quantity}", source="Quest Reward: ${questTitle}"]`;
                        commandTags.push(expTag);
                        console.log(`‚≠ê Generated experience update tag: ${expTag}`);
                    } else {
                        errors.push(`Could not find PC entity to update experience for quest "${questTitle}"`);
                        console.error(`‚ùå No PC entity found for experience reward from quest "${questTitle}"`);
                    }
                    break;

                case 'skill_exp':
                    // Generate skill experience reward command - distributed to all learned skills
                    const skillExpTag = `[SKILL_EXP_REWARD: amount=${reward.quantity}, source="Quest Reward: ${questTitle}", distribution="all_skills"]`;
                    commandTags.push(skillExpTag);
                    console.log(`üéØ Generated skill experience reward tag: ${skillExpTag}`);
                    break;

                case 'skill':
                    // Skills should use SKILL_LEARNED tag instead
                    const skillDescription = `K·ªπ nƒÉng ƒë∆∞·ª£c h·ªçc t·ª´ vi·ªác ho√†n th√†nh nhi·ªám v·ª• "${questTitle}"`;
                    // Find PC name from knownEntities, fallback to "PC" if not found
                    const pcEntityForSkill = Object.values(knownEntities).find(entity => entity.type === 'pc');
                    const learnerName = pcEntityForSkill ? pcEntityForSkill.name : 'PC';
                    const skillTag = `[SKILL_LEARNED: name="${reward.name}", description="${skillDescription}", mastery="S∆° C·∫•p", learner="${learnerName}"]`;
                    commandTags.push(skillTag);
                    console.log(`üéì Generated skill tag: ${skillTag}`);
                    break;

                case 'status':
                    // Status effects should use STATUS_APPLIED_SELF
                    const statusDescription = `Tr·∫°ng th√°i ƒë∆∞·ª£c trao t·ª´ vi·ªác ho√†n th√†nh nhi·ªám v·ª• "${questTitle}"`;
                    const statusTag = `[STATUS_APPLIED_SELF: name="${reward.name}", description="${statusDescription}", type="buff", effects="L·ª£i √≠ch t·ª´ vi·ªác ho√†n th√†nh nhi·ªám v·ª•", source="Quest Reward: ${questTitle}", duration="Vƒ©nh vi·ªÖn"]`;
                    commandTags.push(statusTag);
                    console.log(`‚ú® Generated status tag: ${statusTag}`);
                    break;

                case 'unknown':
                default:
                    // Treat unknown rewards as items with a warning
                    const unknownDescription = `Ph·∫ßn th∆∞·ªüng kh√¥ng x√°c ƒë·ªãnh t·ª´ nhi·ªám v·ª• "${questTitle}": ${reward.originalText}`;
                    const unknownTag = `[ITEM_AQUIRED: name="${reward.name}", description="${unknownDescription}", quantities=${reward.quantity}, usable=true, owner="pc"]`;
                    commandTags.push(unknownTag);
                    errors.push(`Unknown reward type for "${reward.name}" - treating as item`);
                    console.log(`‚ùì Generated unknown reward tag: ${unknownTag}`);
                    break;
            }
        } catch (error) {
            const errorMsg = `Failed to process reward "${reward.name}": ${error}`;
            errors.push(errorMsg);
            console.error(`‚ùå ${errorMsg}`);
        }
    }

    return { commandTags, errors };
};

/**
 * Generate a default description for a reward item
 */
const generateDefaultDescription = (itemName: string, rewardType: string): string => {
    if (rewardType === 'currency') {
        if (itemName.toLowerCase().includes('linh th·∫°ch')) {
            return `${itemName} - lo·∫°i ti·ªÅn t·ªá tu ti√™n c√≥ th·ªÉ d√πng ƒë·ªÉ giao d·ªãch ho·∫∑c tu luy·ªán.`;
        }
        if (itemName.toLowerCase().includes('ƒëi·ªÉm')) {
            return `${itemName} - ƒëi·ªÉm s·ªë t√≠ch l≈©y c√≥ th·ªÉ d√πng ƒë·ªÉ ƒë·ªïi l·∫•y c√°c ph·∫ßn th∆∞·ªüng kh√°c.`;
        }
        return `${itemName} - m·ªôt lo·∫°i t√†i s·∫£n c√≥ gi√° tr·ªã trong th·∫ø gi·ªõi tu ti√™n.`;
    }
    
    return `${itemName} - v·∫≠t ph·∫©m qu√Ω gi√° ƒë∆∞·ª£c trao t·ª´ vi·ªác ho√†n th√†nh nhi·ªám v·ª•.`;
};

/**
 * Process completed quest rewards and generate command tags
 */
export const processQuestRewards = (
    completedQuests: Quest[], 
    knownEntities: { [key: string]: Entity }
): RewardProcessingResult[] => {
    const results: RewardProcessingResult[] = [];

    console.log(`üéØ Processing rewards for ${completedQuests.length} completed quest(s)`);

    for (const quest of completedQuests) {
        console.log(`üèÜ Processing quest: "${quest.title}" with reward: "${quest.reward || 'No reward'}"`);
        
        if (!quest.reward || quest.reward.trim() === '') {
            console.log(`‚ö†Ô∏è Quest "${quest.title}" has no reward specified`);
            results.push({
                rewards: [],
                commandTags: [],
                errors: [`Quest "${quest.title}" has no reward specified`],
                questTitle: quest.title
            });
            continue;
        }

        // Check if rewards have already been granted (anti-duplicate system)
        if ((quest as any).rewardsGranted === true) {
            console.log(`‚ö†Ô∏è Quest "${quest.title}" rewards already granted, skipping`);
            results.push({
                rewards: [],
                commandTags: [],
                errors: [`Quest "${quest.title}" rewards already granted`],
                questTitle: quest.title
            });
            continue;
        }

        try {
            const rewards = parseQuestReward(quest.reward);
            const { commandTags, errors } = generateRewardCommandTags(rewards, quest.title, knownEntities);
            
            results.push({
                rewards,
                commandTags,
                errors,
                questTitle: quest.title
            });

            console.log(`‚úÖ Successfully processed quest "${quest.title}": ${rewards.length} rewards, ${commandTags.length} tags generated`);
        } catch (error) {
            const errorMsg = `Failed to process quest "${quest.title}" rewards: ${error}`;
            console.error(`‚ùå ${errorMsg}`);
            results.push({
                rewards: [],
                commandTags: [],
                errors: [errorMsg],
                questTitle: quest.title
            });
        }
    }

    return results;
};

/**
 * Mark quests as having their rewards granted to prevent duplicates
 */
export const markQuestRewardsAsGranted = (quests: Quest[], completedQuestTitles: string[]): Quest[] => {
    return quests.map(quest => {
        if (completedQuestTitles.includes(quest.title)) {
            return { ...quest, rewardsGranted: true } as Quest & { rewardsGranted: boolean };
        }
        return quest;
    });
};